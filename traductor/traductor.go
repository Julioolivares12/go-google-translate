package traductor

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
)

/*Translate funcion para traducir
sl = idiioma  original
tl = idioma al cual quieres traducir
q = texto a traducir
*/
func Translate(sl string, tl string, q string) (AutoGenerated, error) {
	link := getURL(tl)
	a, err := consume(link, q, tl, sl)
	if err != nil {
		panic(err)
	}
	return a, nil
}

//retorna la url con la configuracion para el idioma a traducir
func getURL(tl string) string {
	return fmt.Sprintf("https://translate.google.com/translate_a/single?client=at&dt=t&dt=ld&dt=qca&dt=rm&dt=bd&dj=1&hl=%s&ie=UTF-8&oe=UTF-8&inputm=2&otf=2&iid=1dd3b944-fa62-4b55-b330-74909a99969e", tl)
}

//devuelve un puntero de request para despues poder construir un json

func consume(link string, q string, tl string, sl string) (AutoGenerated, error) {
	dataForm := url.Values{
		"sl": {sl},
		"tl": {tl},
		"q":  {q},
	}
	r, err := http.PostForm(link, dataForm)

	if err != nil {
		panic(err)
	}
	defer r.Body.Close()
	var autoGenerated AutoGenerated
	if err := json.NewDecoder(r.Body).Decode(&autoGenerated); err != nil {
		fmt.Print(err)
	}

	return autoGenerated, nil
}

//AutoGenerated rs
type AutoGenerated struct {
	Sentences []struct {
		Trans   string `json:"trans"`
		Orig    string `json:"orig"`
		Backend int    `json:"backend"`
	} `json:"sentences"`
	Src        string `json:"src"`
	Confidence int    `json:"confidence"`
	LdResult   struct {
		Srclangs            []string `json:"srclangs"`
		SrclangsConfidences []int    `json:"srclangs_confidences"`
		ExtendedSrclangs    []string `json:"extended_srclangs"`
	} `json:"ld_result"`
}
